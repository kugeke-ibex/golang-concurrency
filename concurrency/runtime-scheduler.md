# Go Runtime Scheduler

## 基本概念

**並列処理(Parallelism)**: 複数のスレッドに対して、複数同時にタスクの処理を行う

**並行処理(Concurrency)**: 一つのスレッドに対して、複数のタスクを短い時間で切り替えてタスクの処理を行う

**main goroutine**: Application レベルの軽量なスレッド

**go task1()**: go keyword で軽量なスレッド(goroutine)を起動できる

## Go Runtime Scheduler の説明

Go のランタイムスケジューラは、GMP モデルで goroutine を管理します。

## GMP モデルの 3 つのコンポーネント

### 1. G (Goroutine)

- ユーザーコードの実行単位
- 軽量なスレッド（数 KB のスタック）
- 数千から数万の goroutine を効率的に管理可能

### 2. M (Machine)

- OS スレッド（実際の実行単位）
- G を実行する
- 通常、M の数は P の数より多く、必要に応じて作成される

### 3. P (Processor)

- 論理プロセッサ（スケジューリングの管理）
- 各 P はローカルキューを持ち、G を管理
- デフォルト数は GOMAXPROCS（`runtime.NumCPU()`で取得される論理 CPU コア数、マシンによって異なる）
- ローカルキューのサイズ: 256（各 P のローカルキューは最大 256 個の G を保持可能）

## 動作メカニズム

### ローカルキュー

各 P は自身のローカルキューから G を取り出し、M 上で実行

### グローバルキュー

すべての P がアクセスできる共有キュー

- 新しい G が作成されたとき、ローカルキューが満杯の場合はグローバルキューに配置される
- P がローカルキューから G を取得できない場合、グローバルキューからも取得を試みる
- グローバルキューはロックが必要なため、ローカルキューよりも優先度が低い

### Work-stealing

P のローカルキューが空の場合、他の P のキューから G を「盗む」ことで負荷分散

**目的**: プロセッサ間で G の処理負荷を均等に分散させ、特定の P が過負荷になるのを防ぐ

**動作の流れ（P のローカルキューが空になった場合）**:

1. グローバルキューの確認: まず、グローバルキューに未処理の G がないかを確認
2. 他の P からの盗み: グローバルキューにも G がない場合、ランダムに選んだ他の P のローカルキューから G を「盗む」
3. 盗む方法: 選んだ P のローカルキューから、キュー内の G の半数を自身のローカルキューに移動させる

**利点**:

- 負荷の均等化: プロセッサ間で G の処理負荷を均等に分散
- スケーラビリティの向上: プロセッサが増加しても、効率的に G を分配・実行可能
- スレッド移動の最小化: ローカルキューを優先的に使用することで、スレッドの移動（マイグレーション）を最小限に抑制

### プリエンプション

長時間実行される G を強制的に中断し、他の G に CPU 時間を割り当てる仕組み

#### Go 1.14 以前

- 関数呼び出しやチャネル操作などの特定のポイントでのみ G の切り替えが発生
- 長時間 CPU を占有する G が存在すると、他の G が実行されにくくなる問題があった

#### Go 1.14 以降

非同期プリエンプションを導入

- ランタイムがバックグラウンドで G の実行時間を監視
- 長時間実行されている G を検出すると、強制的に中断（プリエンプト）して他の G に実行機会を与える
- ランタイムが特定の命令を挿入することで、任意の時点でプリエンプションが可能
- これにより、より公平なスケジューリングが実現され、応答性が向上

### Handoff

G がブロッキングするシステムコールを実行し、M がブロックされた際に、P を他の M に再割り当てする仕組み

**目的**: ブロッキングシステムコール中も他の G がスケジュールされ、実行されることを可能にする

**動作の流れ**:

1. G がシステムコールを実行すると、M がブロックされ、同じ P 上の他の G が実行できなくなる
2. ランタイムが`releasep`関数を呼び出して、P を現在の M から切り離す
3. 解放された P は、アイドル状態の M に再割り当てされるか、新しい M が作成されて割り当てられる

**最適化**:

- 即時ハンドオフ: 長時間ブロックが予測される場合（例：ソケットの読み取り）、即座に実行
- 遅延ハンドオフ: 短時間のブロッキングが予想される場合、sysmon が定期的にチェックし、必要に応じて実行

**復帰時の処理**:

- システムコールから復帰した G は、元の P が利用可能であればそれに再割り当て
- 元の P が利用できない場合、アイドル状態の他の P に割り当て、またはグローバルキューに追加

## まとめ

この仕組みにより、Go は少数の OS スレッドで多数の goroutine を効率的に実行できます。
